# Function that creates a data set from irace performance data
# * irace_file: path to an Rdata file generated by irace
# * remove.na.from: vector of parameter names to indicate the removal of rows (configurations) with NA values in these parameters
# * add.dummy: bool, adding a dummy predictor to be used as reference
# * add.instance: bool, addind the instance as a predictor
# Returns: a list that contains two objects
# * data: dataframe with the generated data
# * pnames: parameter names from the irace data that are included in the data set 
# * type: type of data to build: 
#    - perf: performance (raw)
#    - norm: performance (normalized)
#    - quan: performance quartile
#    - rank: ranking (normalized)
#    - irank: ranking (including imputation)
#    - qrank: ranking quartile (including imputation)
getDataFromIrace <- function(irace_file, remove.na.from=NULL, add.dummy=FALSE, add.instance=TRUE, data.type="perf") {
  load(irace_file)
  if (!exists("iraceResults")) 
    stop("# Error: Provided file does not have an iraceResults object.")
    
  data <- createData(iraceResults$allConfigurations, iraceResults$experiments, iraceResults$parameters, 
             remove.na.from = remove.na.from, add.dummy = add.dummy, add.instance = add.instance, data.type=data.type)
  return(data)
}

# Function createData generates a data set 
# * configurations: configurations data frame
# * experiments: experiments data set
# * remove.na.from: vector of parameter names to indicate the removal of rows (configurations) with NA values in these parameters
# * add.dummy: bool, adding a dummy predictor to be used as reference
# * add.instance: bool, addind the instance as a predictor
# * type: type of data to build: 
#    - perf: performance (raw)
#    - norm: performance (normalized)
#    - quan: performance quartile
#    - rank: ranking (normalized)
#    - irank: ranking (including imputation)
#    - qrank: ranking quartile (including imputation)
createData <- function(configurations, experiments, parameters, remove.na.from=NULL, add.dummy=FALSE, add.instance=TRUE, data.type="perf") 
{
  cat("# Creating training data...\n")
  if (data.type == "perf")  
    cat("# Data dependent variable: Raw performance\n")
  else if (data.type == "norm")  
    cat("# Data dependent variable: Normalized performance\n")  
  else if (data.type == "quan")  
    cat("# Data dependent variable: Quartile performance\n")  
  else if (data.type == "rank")  
    cat("# Data dependent variable: Normalized ranking\n")  
  else if (data.type == "irank")  
    cat("# Data dependent variable: Imputed ranking\n")  
  else if (data.type == "qrank")  
    cat("# Data dependent variable: Imputed quartile ranking\n")  
  else 
    stop("# Error: Unknown data type: ", data.type)
  
  
  # Drop not used columns (.ID., .PARENT.)
  configurations <- configurations[, grep("^\\.", colnames(configurations), invert = TRUE),drop = FALSE]
  rownames(configurations) <- NULL
  
  # Filter variables that are all NA (currently not supported)
  configurations <- filterNACols(configurations)
  if (ncol(configurations) < 2) {
    cat ("# Only ", ncol(configurations)," parameters of the training ",
         "data have NA values. Cannot build data set.\n")
    return(NULL)
  }
  
  # Filter NA rows for parameters in remove.na.from
  if (!is.null(remove.na.from)) {
    cat("# Removing NA rows from", remove.na.from,"\n")
    for (p in remove.na.from) {
      index <- !is.na(configurations[,p])
      configurations <- configurations[index, ,drop=FALSE]
      experiments    <- experiments[,index, drop=FALSE]
    }
  }
  if (nrow(configurations) < 2 || ncol(experiments) < 2) {
    cat ("# Not enough data to train model after removal of configurations with ",
         "parameters ",remove.na.from," set to NA\n")
    return(NULL)
  } 
  
  # Filter variables that have only one value
  uvalues   <- apply(configurations, 2, function(x) length(unique(x)))
  non.equal <- names(uvalues)[uvalues != 1]
  if (length(non.equal)<1) {
    cat ("# Not enough data to train model after removal of ",
         "parameters having only one value in the training set\n")
    return(NULL)
  } else {
    cat ("# Only parameters ", non.equal, " have more than one value for training model\n")
    configurations <- configurations[, non.equal, drop=FALSE]
  }
  
  # Adding dummy parameter to filter non-important parameters and interactions
  if (add.dummy) {
    pnames <- colnames(configurations)
    configurations <- cbind(sample(x = 1:10, size = nrow(configurations), replace = TRUE) ,configurations)
    colnames(configurations) <- c("dummy", pnames)
  }
  
  pnames     <- colnames(configurations)
  inames     <- NULL
  
  if (data.type %in% c("irank", "qrank")) {
    # impute experiment performance by instance
    experiments <- doImputePerformance(experiments)
  }
  
  lapply(1:nrow(experiments), dataNameBind, experiments=experiments, 
         configurations=configurations, add.instance=add.instance, data.type=data.type)
  data <- read.table("rf-data.txt", 
                     header=TRUE, sep=":", stringsAsFactors=FALSE)
  data <- doImputeCols(data, parameters = parameters) 
  
  # Adding instances to the data set
  if (add.instance){
    data[,"instance"] = as.factor(data[,"instance"])
    final.data <- list(data=data, pnames=c(pnames,"instance"), data_type=data.type)
  }else {
    final.data <- list(data=data, pnames=pnames, data_type=data.type)
  }
  return(final.data)
}


reduceData <- function(full_data, remove.na.from, parameters)
{
  cat("# Reducing data frame by ", remove.na.from, "\n")
  data <- full_data$data
  for (pname in remove.na.from) {
    if (!(pname %in% parameters$names)) {
      cat("# WARNING: Parameter:", pname, " not listed in parameters object (skipping)\n")
      next
    }
    if (parameters$type[pname] %in% c("c", "o")) 
      data <- data[(data[,pname] != "__miss__"),]
    else 
      data <- data[(data[,pname] <= parameters$domain[[pname]][2]),]
    
    if (nrow(data) <= 2) {
      cat("# Not enough data after reduction with parameters:", remove.na.from, "\n")
      return(NULL)
    }
  }
  
  # resample dummy to ensure its uniform
  if ("dummy" %in% colnames(data)) {
    data[, "dummy"] <- runif(nrow(data), 1, 10)
  }
  
  # check if any parameter is left with a single value and remove it
  for (pname in full_data$pnames) {
    v <- unique(data[,pname])
    if (length(v)<2) {
      cat("#   Parameter:", pname, " has only one value and will be removed from data set\n")
      data <- data[, !(colnames(data) %in% pname)]
    }
  }
  
  full_data$data <- data
  full_data$pnames <- full_data$pnames[full_data$pnames %in% colnames(data)]
  return(full_data)
}


# Function filterNACols remove columns (parameters) that only have NA values
# * configurations: configurations data frame
filterNACols <- function(configurations) 
  {
  all.na <- which(colSums(is.na(configurations)) == nrow(configurations))
  
  if (length(all.na)>0) {
    cat("Warning: Removing parameters with only NA values ", colnames(configurations)[all.na], "\n")
    pnames <- colnames(configurations)[-all.na]
    configurations <- configurations[,pnames, drop=FALSE]
  }
  return(configurations)
}

# Function dataNameBind generates a dataset file 
# * index: experiment index to add to the file
# * experiments: experiments data frame
# * configurations: configurations data frame
# * file: filename to which data entries should be added
# * add.instance:  bool, adding instance as a predictor variable
# * type: type of data to build: 
#    - perf: performance (raw)
#    - norm: performance (normalized)
#    - quan: performance quartile
#    - rank: ranking (normalized)
#    - irank: ranking (including imputation)
#    - qrank: ranking quartile (including imputation)
dataNameBind <- function (index, experiments, configurations, file="rf-data.txt", add.instance=TRUE, data.type="perf") {
  
  get_quartile <- function (v, q) {
    return(min(which(v <= q)))
  }
  
  # get experiment data 
  experiment <- experiments[index,]
  
  #remove infinite and NA experiments (rejected)
  not.inf.na <- !is.infinite(experiment) & !is.na(experiment)
  experiment <- experiment[not.inf.na]
  if (length(experiment) < 1)
    return
  all.configurations <- configurations[not.inf.na,]
  
  # Performance transformation
  if (data.type %in% c("rank","irank", "qrank")) {
    # apply rank
    experiment <- rank(experiment)
  }
  
  if (data.type == "rank") {
    min.rank   <- 1
    max.rank   <- ncol(experiments)
    experiment <- (experiment - min.rank) / (max.rank -min.rank)
  }
  
  if (data.type == "norm") {
    min.exp    <- min(experiment)
    max.exp    <- max(experiment)
    experiment <- (experiment - min.exp) / (max.exp -min.exp)
  } 
  
  if (data.type %in% c("quan", "qrank")) {
    # get quartile
    q <- quantile(experiment, na.rm=TRUE)
    qexperiment <- sapply(experiment, get_quartile, q=q)
    experiment  <- qexperiment
  }
  
  # add instance as predictor and join data
  if (add.instance) {
    all.instances  <- matrix(paste("instance",index,sep=""), ncol=1, nrow=length(experiment))
    data           <- cbind(all.configurations, all.instances, experiment)
    colnames(data) <- c(colnames(all.configurations), "instance", ".PERFORMANCE.")
  } else {
    data           <- cbind(all.configurations, experiment)
    colnames(data) <- c(colnames(all.configurations), ".PERFORMANCE.")
  }
  
  # Write lines (data entries) to the file
  if (index==1)
    write.table(data, append=FALSE, sep=":", row.names=FALSE, col.names=TRUE, quote=FALSE, file=file)
  else
    write.table(data, append=TRUE, sep=":", row.names=FALSE, col.names=FALSE, quote=FALSE, file=file)
}

# Function doImputeCols imputes parameter configuration data. Categorical variables are imputed as 
# __miss__ and numerical as the domain upper bound * 2
# * data: data frame with data entries
# * pnames: parameter names to be considered in the imputation
doImputeCols <- function(data, pnames=NULL, parameters) 
  {
  cat("# Imputing parameter data...\n")
  
  if(is.null(pnames))
    pnames <- parameters$names  
  
  for (pname in pnames) {
    if (!(pname %in% colnames(data))) {
      cat("# Skipping imputation of ", pname, "\n")
      next;
    }
    sel <- is.na(data[,pname])
    if (sum(sel) >= 1) {
      cat("# Imputing", sum(sel),"/",length(sel),"values in", pname, "type", parameters$types[pname],"\n")
      if (parameters$types[pname] %in% c("r","i", "ilog", "rlog")) {
        data[sel ,pname] <- parameters$domain[[pname]][2] * 2
      } else if (parameters$types[pname] %in% c("c","o")) {
        data[,pname] <- as.character(data[,pname])
        data[sel ,pname] <- rep("__miss__", sum(sel))
      }
    }
    
    if (parameters$types[pname] %in% c("c","o")) {
      data[,pname] <- factor(data[,pname], ordered=FALSE)
    }
  }
  
  if (".PERFORMANCE." %in% colnames(data)){
    data[,".PERFORMANCE."] <- as.numeric(data[,".PERFORMANCE."])
  }
  return(data)
}

# Function doImputePerformance imputes experiment performance. NA experiments are imputed,
# while Inf experiments are not imputed and should be handled later
# * experiments: experiments data frame
# TODO: improve imputation
doImputePerformance <- function(experiments) {
  na_by_conf <- apply(experiments, 2, function(x) sum(is.na(x)))
  for (i in 1:nrow(experiments)) {
    #impute ranks by adding rank by number of experiments to baseline executed configuration
    exps_na       <- is.na(experiments[i,])
    rank_exps_na  <- rank(na_by_conf[exps_na])
    experiments[i,exps_na] = max(experiments[i, which(experiments[i,] < Inf)]) + rank_exps_na
  }
  return(experiments)
}



